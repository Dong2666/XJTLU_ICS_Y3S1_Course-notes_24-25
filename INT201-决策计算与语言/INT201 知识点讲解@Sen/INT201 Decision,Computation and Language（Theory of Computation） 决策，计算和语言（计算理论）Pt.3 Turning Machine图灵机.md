- [1. Turing Machine and Variants （图灵机及其变种）](#1-turing-machine-and-variants-图灵机及其变种)
  - [1.1 Turing Machine（图灵机）](#11-turing-machine图灵机)
  - [1.2 图灵机的形式化定义](#12-图灵机的形式化定义)
  - [1.3图灵机的例子](#13图灵机的例子)
  - [1.4 图灵机的变种](#14-图灵机的变种)
    - [1.4.1 Multi-tape Turing Machine（多带图灵机）](#141-multi-tape-turing-machine多带图灵机)
    - [1.4.2 Nondeterministic Turing Machine（非确定型图灵机）](#142-nondeterministic-turing-machine非确定型图灵机)
    - [1.4.3 图灵机与现代计算机的相似性](#143-图灵机与现代计算机的相似性)
  - [1.5 Language Hierarchy（语言层次结构）](#15-language-hierarchy语言层次结构)
- [2. Church-Turing Thesis and Limits of Computation（丘奇-图灵论题与计算的极限）](#2-church-turing-thesis-and-limits-of-computation丘奇-图灵论题与计算的极限)
  - [2.1 希尔伯特问题](#21-希尔伯特问题)
  - [2.2 Decidable languages（可判定语言）](#22-decidable-languages可判定语言)
    - [2.2.1 与正则语言相关的可判定性问题](#221-与正则语言相关的可判定性问题)
    - [2.2.2 与上下文无关语言相关的可判定性问题](#222-与上下文无关语言相关的可判定性问题)
  - [2.3 Undecidable languages（不可判定语言）](#23-undecidable-languages不可判定语言)
    - [2.3.1 Diagonalization method（对角化方法）](#231-diagonalization-method对角化方法)
    - [2.3.2 Non Turning-recognizable languages（图灵不可识别语言）](#232-non-turning-recognizable-languages图灵不可识别语言)
- [3. Reducibility and Rice’s Theorem(可归约性和赖斯定理）](#3-reducibility-and-rices-theorem可归约性和赖斯定理)
  - [3.1 Background](#31-background)
  - [3.2 Reducibility（可规约性）](#32-reducibility可规约性)
  - [3.3 Mapping reducibility/Many-one reducibility（映射可归约性/多一可归约性）](#33-mapping-reducibilitymany-one-reducibility映射可归约性多一可归约性)
    - [3.3.1 Computable function（可计算函数）](#331-computable-function可计算函数)
    - [3.3.2 映射可归约性的形式化定义](#332-映射可归约性的形式化定义)
  - [3.4 Rice’s Theorem（赖斯定理）](#34-rices-theorem赖斯定理)
    - [3.4.1 赖斯定理的形式化定义](#341-赖斯定理的形式化定义)

# 1. Turing Machine and Variants （图灵机及其变种）
前面学习的Finite Automata和Pushdown Automata都有识别不了的语言如$A = \{a^mb^nc^{mn},m≥0,n≥0\}$。现在介绍一个能力更强的自动机——Turing Machine（图灵机）。它与有穷自动机相比，有无限大的容量的存储并且可以任意访问内部数据。图灵机可以模拟实际计算机的所有计算行为，但其也有不能解的问题，这些问题正是超出了计算理论的极限的问题。

## 1.1 Turing Machine（图灵机）
图灵机用一个无限长的带子作为无限存储，这条带子与PDA的栈（stack）类似，分为多个小格，每一个小格存储一个属于$Γ$（带子字母表）的符号。
它有一个读写头，能再带子上读、写和左右移动。
当图灵机开始运作时，带子上只有输入串，其他地方都是空的，如果需要保存信息，它可将这个信息写在带子上。为了读已经写下的信息，它可将读写头往回移动到这个信息所在的位置。运作也就是机器进行计算也就是我们熟知的状态在进行转移，机器会一直到输出才会停止，这个输出结果是accept（接受）或reject（拒绝），这将会是因为机器进入了accept state（接受状态）和reject state（拒绝状态）导致的。如果不能进入任何接受或拒绝状态，就继续执行下去，永不停止。

有穷自动机与图灵机之间的区别：
1.图灵机在带子上既能读也能写。
2.图灵机的读写头既能向左也能向右移动。
3.图灵机的带子是无限长的。
4.图灵机进入拒绝和接受状态将立即停机。

下面我们通过一个例子更好理解图灵机：
图灵机$M_1$可以识别语言$A=\{w\#w|w∈ \{0, 1\}^∗\}$。我们可能想到的方案是让机器先记住$w$然后再去一个一个符号判断是否与$\#$后的$w$是否一致。但其实如果$w$很长，记住这么长的$w$是很难的，我们可以直接一个一个符号去匹配，因为我们的图灵机可以自由地在带子上移动，图灵机可以在带子上写，所以它可以用记号记录匹配的位置。
因此我们就得到了我们的图灵机。我们会让读写头在带子上反复移动以匹配$\#$前后的字符串中的符号是否一致，消除检查过的字符，如果最后所有的符号都被消除，那就意味着匹配成功，因此图灵机进入接受状态。如果发现一个不匹配，就进入拒绝状态。
因此$M_1$的算法为：
1.在$\#$两边对应的位置来回移动。检查这些对应位置是否包含相同的符号，如不同，或者没有$\#$，则拒绝。为记录对应的符号，消去所有检查过的符号。
2.当$\#$左边的所有符号都被消去时，检查$\#$的右边是否还有符号，如果仍有，则拒绝，否则接受。
以$011000\#011000$为例，下图展示了$M_1$的带子的几个非连续的快照。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1f3a477fb2644aeb8a65555d7883ce64.jpeg#pic_center)
下面介绍图灵机的形式化定义。

## 1.2 图灵机的形式化定义
图灵机的核心是转移函数$δ$，它说明了机器中configuration（格局）的变化（格局是图灵机中当前状态、带子内容和读写头位置在一起的组合），因此$δ$的形式如下：$Q×Γ→Q×Γ×\{L,R,N\}$,亦即，若机器处于状态$q$,读写头所在的带子放个内包含符号$a$，则当$δ(q,a)=(s,b,L)$时，机器写下符号$b$以取代$a$，并进入状态$s$。第三个分量$L$或$R$或$N$指出在写带之后，读写头是向左$(L)$还是向右$(R)$移动还是不移动$N$。如图所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8ce8245c3c9f4fd89474b40fb0de70a2.png)


图灵机是一个7元组$(Q,Σ,Γ,δ,q_0,q_{accept},q_{reject})$,其中：$Q,Σ,Γ$都是有穷集合，并且
1.$Q$是状态集。
2.$Σ$是输入字母表，不包括特殊空白符号$\sqcup$。
3.$Γ$是带子字母表，其中$\sqcup∈Γ，Σ∈Γ$。
4.$δ：Q×Γ→Q×Γ×\{L,R,N\}$是转移函数。
5.$q_0∈Q$是起始状态。
6.$q_{accept}∈Q$是接受状态。
7.$q_{reject}∈Q$是拒绝状态，且$q_{accept}≠q_{reject}$。
图灵机$M=(Q,Σ,Γ,δ,q_0,q_{accept},q_{reject})$的计算方式如下：开始时，$M$以最左边的n个带子方格接受输入$w=w_1w_2...w_n∈Σ^*$,带子的其余部分保存空白（即填以空白符），读写头从最左边的带子方格开始运行，注意$Σ$不含空白符，故出现在带子上的第一个空白符表示输入的结束。$M$开始运行后，计算根据转移函数所描述的规则进行。如果$M$试图将读写头从带子的最左端再向左移动，即使转移函数的符号是$L$,那也不移动。计算一直持续到它接受或拒绝状态，此时停机。如果两者都不发生。则$M$将永远运行下去。
我们为了方便表示格局，将以如下特殊方式表示。对于状态$q$和带子字母表$Γ$上的两个字符串$u$和$v$，以$uqv$表示如下格局：当前状态是$q$，当前带子内容是$uv$，读写头的当前位置是$v$的第一个符号，带子上$v$的最后一个符号以后的符号都是空白符。例如，$1011q_701111$表示如下格局：当前带子内容是$101101111$，当前状态是$q_7$，读写头当前在第二个$0$上。如图所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4f47dbbd1e57447abb84054882cb93a2.jpeg#pic_center)

下面对计算方式形式化：如果图灵机能合法地从格局$C_1$一步进入$C_2$，则称格局$C_1$yields（产生）$C_2$,这个概念的形式化定义如下：
设$a,b$和$c$是$Γ$中的符号，$u$和$v$是$Γ^*$中的字符串，$q_i$和$q_j$是状态，则$uaq_ibv$和$uq_jacv$是两个格局。如果转移函数满足$δ(q_i,b)=(q_j,c,L)$，则说$uaq_ibv$产生$uq_jacv$。如图所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/87744cbe819746ae8987d6f61134b0dc.png)

右移同理，如果$δ(q_i,b)=(q_j,c,R)$，则有$uaq_ibv$产生$uacq_jv$。当然当读写头处于格局的两个端点之一时，会发生特殊变化。对于左端点，如果转移是向左移动，因为机器带子在最左端不会再往左，因此是格局$q_ibv$产生$q_jcv$。如果是对于右端点的向右移动，格局$uaq_i$等价于$uaq_i\sqcup$，因为之前定义了在带子上没有描述的部分都是空格。这样，这里的处理就跟以前一致，因为右端点不存在。
$M$在输入$w$上的start configuration（起始格局）是格局$q_0w$，表示机器处于起始状态$q_0$，并且读写头处于带子的最左端位置。在accepting configuration（接受格局）里，状态时$q_{accept}$。在rejecting configuration（拒绝格局）里，状态时$q_{reject}$。接受和拒绝状态都是halting configuration（停机格局），它们都不在产生新格局。因为机器只在接受或拒绝状态下才停机，因此可以等价地将转移函数记为$δ：Q'×Γ→Q×Γ×\{L,R,N\}$，其中$Q’$是去掉状态$q_{accept}$和$q_{reject}$的$Q$。图灵机$M$ accept（接受）输入$w$，如果存在格局的序列$C_1,C_2,...,C_k$使得：
1.$C_1$是$M$在输入$w$上的起始格局；
2.每一个$C_i$产生$C_{i+1}$；
3.$C_k$是接受格局。
$M$接受的字符串的集合称为$M$的语言，或被$M$识别的语言，记作$L(M)$。
因此如果一个语言能被某一图灵机识别，则称该语言是Turing-recognizable（图灵可识别的）或者该语言是recursively enumerable（递归可枚举语言）。
在输入上运行一个图灵机时，可能出现三种结果：接受、拒绝或loop（循环）。这里循环指的是机器不halt（停机），背后的原因可能是简单的也可能是复杂的，但是都没有导致机器停机。
对于一个输入，图灵机有两种方式不接受它：一种是进入拒绝状态而拒绝它，另一种是进入循环。有时候，很难区分机器是进入了循环还是需要耗费长时间运行，而且根据停机问题我们无法保证我们能够有效地知道这个图灵机在给定输入下是否停机。因此我们更喜欢对所有输入都停机的图灵机，它们永不循环，称这种机器为decider（判定器），因为它们总能决定是接受还是拒绝。对于可以识别某个语言的判定器，称其decide（判定）该语言。
因此如果一个语言能被某一图灵机判定，则称它是图灵可判定的，简称decidable（可判定的）或递归语言。

下面我们会给出一些图灵机的例子，这些例子是可判定语言，每一个可判定语言都是图灵可识别的。

## 1.3图灵机的例子
为了方便起见，这里给出较高层次的描述，这种描述足够精确也容易理解得多。而这种描述起始也可以改成形式化描述。
例子：描述图灵机$M_2$他判定地语言是所有由0组成，长度为2的方幂的字符串，即$A=\{0^{2^n}|n≥0\}$
$M_2$对于输入字符串$w$：
1.从左往右扫描整个带子，隔一个字符消去一个0.
2.如果在第1步之后，带子上只剩下唯一的一个0，则接受。
3.如果在第1步之后，带子上包含不止一个0，并且0的个数是奇数，则拒绝。
4.读写头返回至带子的最左端。
5.转到第一步。
每重复一次第1步，小区一半个数的0。由于在第1步中，机器扫描了整个带子，故它能够知道它看到的0的个数是奇数还是偶数。如果是大于1的奇数，则输入中所含的0的个数不可能是2的方幂，此时机器就拒绝。但是，如果看到0的个数是1，则输入中所含的0的个数肯定是2的方幂，此时机器就接受。
其的形式化语言$M_2=(Q,Σ,Γ,δ,q_1,q_{accept},q_{reject})$如下：
1.$Q=\{q_1,q_2,q_3,q_4,q_5,q_{accept},q_{reject}\}$。
2.$Σ=\{0\}$。
3.$Γ=\{0,x,\sqcup\}$。
4.$δ$如图。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9648b5b10dcf43de99d7fa6eca37459f.png)

5.开始、接受和拒绝状态u分别是$q_1,q_{accept},q_{reject}$。
其实这个自动机的接受状态可以理解成只有1个0的字符串，然后通过循环将所有其他的2的方幂在每一次循环中除以2，从而构造成只有1个0的字符串，从而接受，中间为了方便，将非2的方幂的字符串直接拒绝。
以输入0000为例，因此起始格局是$q_10000$,机器的格局序列如下，顺序从上到下再从左到右。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/46df46bf29a54067b094f57b99be0f4c.jpeg#pic_center)
例子：本节开始的时候给出了一个图灵机$M_1$的例子，现在给出其形式化描述$M_1=(Q,Σ,Γ,δ,q_1,q_{accept},q_{reject})$，它判定的语言是$A=\{w\#w|w∈ \{0, 1\}^∗\}$。
1.$Q=\{q_1,q_2,q_3,q_4,q_5,q_6,q_7,q_8,q_{accept},q_{reject}\}$。
2.$Σ=\{0,1,\#\}$。
3.$Γ=\{0,1,\#,x,\sqcup\}$。
4.用状态图描述$δ$如下。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/37bc4989105449dab78efe6e24ae16c3.png)
5.开始、接受和拒绝状态u分别是$q_1,q_{accept},q_{reject}$。
其中从$q_4$到$q_4$的转移中，为方便起见，使用了简略写法$x→R$表示当机器正在读$x$且状态为$q_4$时，向右移动，但不改变带子，因此$δ(q_4,x)=(q_4,x,R)$。而其中从$q_2$到$q_2$的转移中，这里的$0，1→R$也是一种简略写法，表示当机器在状态$q_2$且读0或1时，保持状态$q_2$不动，不改变带子上的符号，读写头向右移动。
我们之前提到这个的算法是：1.在$\#$两边对应的位置来回移动。检查这些对应位置是否包含相同的符号，如不同，或者没有$\#$，则拒绝。为记录对应的符号，消去所有检查过的符号。
2.当$\#$左边的所有符号都被消去时，检查$\#$的右边是否还有符号，如果仍有，则拒绝，否则接受。
这里的第1步由状态$q_1$到$q_7$实现，第2步由其余状态实现。为简化状态图，没有在图中显示拒绝状态，也没有显示到拒绝状态的转移。这种转移隐式地表现为：一个状态对某个特殊符号没有向外地转移。例如，对于状态$q_5$，没有画出由$\#$向外的箭头，因此，当状态为$q_5$且读写头下的符号为$\#$时，就进入拒绝状态$q_{reject}$。对于这些转移函数，如果读写头向右移，机器便进入拒绝状态。

例子：图灵机$M_3$可以做一些初等算数，它判定语言$A=\{a^ib^jc^k|i×j=k,且i,j,k≥1\}$
$M_3$对于输入字符串$w$：
1.从左到右扫描输入，确认输入具有形式$a^+b^+c^+$，否则拒绝。
2.读写头返回到带子的左端点。
3.消去一个$a$，并向右扫描直到$b$出现。在$b$与$c$之间来回移动，成对地消去b和c，直到把所有的$b$都消去。如果$c$已经全被消去还有$b$，则拒绝。
4.如果还要$a$未消去，则回复所有已消去的b，再重复第3步，如果所有的$a$都已被消去，则检查所有的$c$是否都被消去。如果是则接受，否则拒绝。
比如2个$a$，1个$b$，2个$c$的情况，我们先消去1个$a$后我们发现还要$a$未被消去，然后我们再消去1个$a$，因为我们一共消去了2个$a$，我们此时消去1个$b$的时候应该消去2个$c$，此时我们发现$b$全部被消去后，$c$也全部被消去，因此接受。
这里第二步的实现可以像前面的第一个例子一样，用一个特殊符号记录这个左端点，我们只需要向左扫描直到找到这个符号就可以回到左端点。其实我们也可以利用图灵机在最左端无法再向左的特性，将最左端的这个符号暂时改成一个特殊符号，然后试着向左移动，如果没有移动说明这里的确是左端点，如果移动成功了，那就说明这里不是左端点，但这个方法需要将改变了的符号还原为原来的符号。

例子：图灵机$M_4$可以解决（elements distinctness problem）元素区分问题。给出由$\{0, 1\}$组成的字符串系列，字符串之间用$\#$隔开，$M_4$的任务是，如果词序列中的所有字符串都不相同，则接受。此语言是：
$A=\{\#x_1\#x_2\#...\#x_l|x_i∈\{0,1\}^*,且对任意i≠j，有x_i≠x_j\}$
机器$M_4$将$x_1$与$x_2$到$x_l$进行比较，然后将$x_2$与$x_3$到$x_l$进行比较，以此类推。$M_4$判定这个语言的非形式化描述如下。
$M_4$对于输入字符串$w$：
1.在最左端的带子符号的顶上做个记号。如果此带子符号是空白符，则接受。如果此符号是$\#$，则进行下一步。否则，拒绝。
2.向右扫描至下一个$\#$，并在其顶上做第二个记号。如果在遇到空白符之前没有遇到$\#$，则说明带子上只有$x_1$，因此接受。
3.通过来回移动，比较做了记号的$\#$的右边的字符串，如果它们相等，则拒绝。
4.将两个记号中右边的那个记号向右移到下一个$\#$上。如果在碰到空白符之前没有遇到$\#$，则将左边的记号向右移到下一个$\#$上，并将第二个记号移到后面的$\#$上。如果此时右边记号还找不到$\#$，则说明所有的字符串都已经比较过了，因而接受。
5.转到第3步继续执行。

上述的四个例子所描述的语言都是可判定的。每个可判定语言都是图灵可识别的，所以这些语言都是图灵可识别的。而要说明一个语言图灵可识别但不可判定，则比较困难，将会在下一节介绍。

## 1.4 图灵机的变种
### 1.4.1 Multi-tape Turing Machine（多带图灵机）
多带图灵机只是比普通图灵机相比有多个带子，每个带子都要自己的读写头，用于读和写。开始时，输入出现在第一个带子上，其他的带子都是空白的。转移函数改为允许多个带子同时进行读、写和移动读写头，其形式为:$δ:Q×Γ^k→Q×Γ^k×\{L,R,N\}^k$。此处$k$是带子的个数。表达式为$δ(q_i,a_1,...,a_k)=(q_j,b_1,...,b_k,L,R,...L)$指的是：若机器处于状态$q_i$，读写头$1$到$k$所读的符号分别是$a_1$到$a_k$，则机器转移到状态$q_j$，各读写头分别写下符号$b_1$到$b_k$，并按此式所指示的那样移动每个读写头。

似乎多带图灵机的能流比普通图灵机强，但实际上它们是等价的。我们现在就证明每个多带图灵机等价于某一个单带图灵机。
因此我们就是要将一个多带图灵机$M$转换为一个与之等价的单带图灵机$S$，关键是怎样用$S$来模拟$M$。
假设$M$有$k$个带子，$S$把此$k$个带子的信息都存储在它的唯一带子上，并以此来模拟$k$个带子的效果。它用一个新的符号$\#$作为定界符，以分开不同带子的内容。除了带子内容外，$S$还必须记录每个读写头的位置。为此，它在一个符号的顶上加个点，以此来标记读写头在其带子上的位置，$S$把它们想象为虚拟带子和虚拟带子和虚拟读写头。这些加点的带子符号是已经加进子字母表的新符号。如图所示便是将$M$的三个带子用$S$的一个带子表示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e1d1916a51f34668b8799531612e6c13.jpeg#pic_center)
$S$对于输入$w=w_1...w_n$:
1.$S$在自己的带子上放入
$\#\dot{w}_1w_2...w_n\#\dot{\sqcup}\#\dot{\sqcup}\#...\#$此格式表示了$M$的全部$k$个带子的内容。
2.为了模拟多带机的一步移动，$S$在其带子上从标记左端点的第一个$\#$开始扫描，一直扫描到标记右端点的第$(k+1)$个$\#$，其目的是确定虚拟读写头下的符号。然后$S$进行第二次扫描，并根据$M$的转移函数指示的运行方式更新带子。
3.任何时候，只要$S$将某个虚拟读写头向右移动到某个$\#$上面，这就意味着$M$已将自己对应的读写头移动到了其所在的带子中的空白区域上，即以前没有读过的区域上。因此,$S$在这个带子方格上写下空白符，并将这个带子方格到最右端的各个带子方格中的内容都向右移动一格。然后再像之前也一样继续模拟。

因此我们可以得到一个推论：一个语言是图灵可识别的，当且仅当存在多带图灵机识别它。

### 1.4.2 Nondeterministic Turing Machine（非确定型图灵机）
与前面的非确定型自动机同理，在计算过程中，机器可以在多种可能性动作中选择一种继续进行。它的转移函数具有如下形式：$δ:Q×Γ→P(Q×Γ×\{L,R\})$,下图展示了其中一个例子。![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fdfbefd9182347f3bc64d3bd0f391b51.png)
因此其的计算是一棵树，不同分支对应着机器的不同的可能性动作。如果计算的某个分支导致接收状态，则机器接受该输入。如图所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b27b60ebf53642febf2e517e1a91b979.png)
现在证明非确定型不会影响图灵机模型的识别能力。也就是每个非确定型图灵机都等价于某一个确定型图灵机。
证明思路：用确定型图灵机$D$来试验非确定型图灵机$N$的非确定性计算的所有可能分支。若$D$能在某个分支到达接受状态，则接受。否则$D$的模拟将永不终止。
将$N$在输入$w$上的计算看作是一棵树，树的每个分支代表非确定型图灵机的一个分支，结点时$N$的一个格局，根是起始格局，图灵机$D$在这棵树上搜索接受格局。为避免没有访问整棵树，我们可以使用宽度优先策略搜索此树。这种方式可以避免如果我们以深度优先策略而遇到某个无限深度的分支时陷入了无法访问其他分支的问题。使用宽度优先保证了$D$可以访问树的所有结点，直到它遇到接受格局。
证明：模拟确定型图灵机D有三个带子，由于之前的证明，所以这等价于只有一个带子。机器$D$将这三个带子用于专门用途。如图第一个带子只包含输入串，且不再改变。第二个存放$N$的带子的内容，此内容对于$N$的非确定型计算的某个分支。第三个带子记录$D$在$N$的非确定性计算树中的位置。![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7a6d9d274f5945fd8e11977b49069ad1.png)
首先考虑第三个带子上表示的数据。$N$中的每个格局确定一个集合，它是由此格局可能转移到的所有下一格局组成，这些下一格局是由$N$的转移函数指定的。$N$的非确定型计算中的每个结点最多有$b$个子结点，其中$b$是上述集合中最大集合所含的元素个数。对树的每个结点，可以给其分配一个地址，它是字母表$Γ_b=\{1,2,...,b\}$上的一个串。例如，把地址231分配给按以下方式到达的结点：从根出发走到它的第二个子节点，在由此走到第三个子节点，最后由此走到第一个子节点。此串中的数字告诉我们：在模拟$N$的非确定型计算的一个分支时下一步应做什么。如果一个格局拥有的选择太少，则一个符号可能不对应任何选择，此种情况下，地址将无效，不对应任何结点。第三个带子上包含$Γ_b$上的一个串，它代表$N$的计算树中的如下分支：起点是根，终点是此串表示的地址所对应的结点，除非这个地址是无效的。空串是树根地址。$D$的描述如下：
1.开始时，第一个带子包含包含输入$w$，第二个和第三个带子是空的。
2.把第一个带子复制到第二个带子上，并将第三个带子的字符串初始化为$ε$。
3.用第二个带子去模拟$N$在输入$w$上的非确定型计算的某个分支。在$N$的每一步动作之前，查询第三个带子上的下一个数字，以决定在$N$的转移函数所允许的选择中做何选择。如果第三个带子上没有符号剩下，或这个非确定型的选择是无效的，则放弃这个分支，转到第4步。如果遇到拒绝格局也转到第4步。如果遇到接受格局，则接受这个输入。
4.在第三个带子上，用字符串顺序的下一个串来代替原有的串。转到第2步，以模拟$N$的计算的下一个分支。


### 1.4.3 图灵机与现代计算机的相似性
图灵机虽然简单，但具有复制计算机操作所需的基本功能：
它可以读取/写入离散符号（代表二进制数据）
它有一个有限的状态集（类似于CPU的指令集）
它有无限的内存（带子）来存储数据
它遵循确定性规则进行状态转换
由于任何计算机程序都可以被分解为这些基本操作，因此图灵机可以通过以下方式模拟它：
使用它的带子来表示内存和程序指令
使用它的状态来实现指令集
遵循它的转换规则来执行程序

## 1.5 Language Hierarchy（语言层次结构）
前面说过如果存在一个图灵机，对于该语言中的每个可能的输入字符串，图灵机都能在有限时间内进入停机状态并给出明确的接受或拒绝结果，那这个语言是decidable language（可决定语言）。每一个可决定语言都是图灵可判断的，但每一个图灵可判断的不一定都是可决定语言，它们可能是undecidable language（不可决定语言）。
下图说明了这些语言之间的关系。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/674ecf1b169e437b99b75faa6e8a724b.png)
其中decidable language（可决定语言）包括：
1.Regular languages（正则语言）
2.Context-free languages（上下文无关语言）
3.All finite languages（所有有限语言）
4.Languages of palindromes（回文的语言）
5.Languages of composite numbers（复合数的语言）
6.Languages of sorted sequences（排序序列的语言）
而undecidable language（不可决定语言）包括：
 1.The Halting Problem - determining if a program will halt（停机问题——确定一个程序是否会停机）
 2.The problem of determining if a Turing Machine accepts any string（确定图灵机是否接受任何字符串的问题）
 3.The problem of determining if two Turing Machines are equivalent（确定两个图灵机是否等价的问题）
 4.The problem of determining if a context-free grammar generates all strings（确定一个上下文无关文法是否生成所有字符串的问题）

# 2. Church-Turing Thesis and Limits of Computation（丘奇-图灵论题与计算的极限）
## 2.1 希尔伯特问题
23个希尔伯特问题中的第10个问题是关于算法的，这个问题希望设计一个算法来检测一个多项式是否有整数根。原文用的表达是通过有限多次运算就可以决定的过程。这个表达的意思便是假设有这个算法，并希望有人能找到它。
现在我们知道，这个任务没有算法吗，换句话说是它在算法上是不可解的。但对于那个时期的数学家来说，他们对算法的直观认识不足以得出这个结论。姚证明算法不存在需要给出算法的明确定义，而在Alonzo Church（丘奇）和Alan Turing（图灵）于1936年写的文章中，他们给出了算法的定义。丘奇使用称为$λ$-演算的记号系统来定义算法，图灵使用机器来做同样的事情。这两个定义后来被证明是等价的，算法的非形式化概念和精确定义之间的这个联系从此被称为Church–Turing Thesis（丘奇-图灵议题），如图。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c1d7b3f2e91b471c887620caf8590d63.png)
在丘奇-图灵议题提出的算法定义的基础上，人们证明了检查多项式是否有整数根的算法是不存在的。后面正是要详细阐述这种可以用来证明这个结论以及一些其他问题也是算法不可解的技术，
现在重新阐述希尔伯特第10问题。
$D=\{p|p是有整数根的多项式\}$，对于这个集合$D$是不是可判定的？答案是否定的。下面先证明$D$是图灵可识别的。证明之前，先讨论一个简单问题，不同的是现在仅考虑只有一个变元的多项式，如$4x^3-2x^2+x-7$。设$D_1=\{p|p是有整数根的x的多项式\}$，下面是识别$D_1$的图灵机$M_1$:输入是关于变元$x$的一个多项式$p$。1.当$x$相继被设置为值0，1，-1，2，-2，3，-3，...时，求$p$的值。一旦求得$p=0$，就接受。
如果$p$有整数根，$M_1$最终将找到它，从而接受。如果$p$没有整数根，则$M_1$将永远运行下去。对于多个变元的情形，可以设计一个类似的图灵机$M$来识别$D$，只是$M$要检查多个变元所有可能取的整数值。
$M_1$和$M$都是识别器而非判定器。$M_1$可以被转换为$D_1$的判定器，因为可以计算出一个上街，使得一个单变元的所有跟都在这个上界内，这样，只要在这个上界以内进行搜索即可。如果在这个上界之内找不到根，机器则拒绝。但是Matijasevisc（马提亚塞维奇）定理表明对于多变元多项式，计算这样的上界是不可能的。

## 2.2 Decidable languages（可判定语言）
现在我们通过丘奇-图灵论题，用图灵机定义了算法概念。我们现在将关注涉及自动机和文法的语言。例如，提出一个算法来检测一个串是否是一个上下文无关语言中的元素。或者说是测试一个上下文无关法是否可以生成某一个串，这一问题和程序设计语言中的程序识别及编译有关。我们现在先涉及可判定的，后续我们会继续探讨不可判定的例子。

### 2.2.1 与正则语言相关的可判定性问题
我们将给出算法来检测一个有穷自动机是否接受一个串、一个有穷自动机的语言是否空以及两个有穷自动机是否等价等问题。
因为已经建立了处理语言的术语，故为方便起见，就用语言来表示各种计算问题。例如DFA acceptable problem（接受问题），检测一个特定的确定型有穷自动机是否接受一个事先给定的串，此问题可表示为语言$L_{DFA}$，它包含了所有DFA的编码以及DFA接受的串的编码。令$L_{DFA}=\{<B,w>|B是DFA并且接受输入串w\}$
问题“DFA $B$是否接受输入$w$”与问题"$<B,w>$是否是$L_{DFA}$的元素"是相同的。类似地，其他一些计算问题也可表示成检查语言的成员隶属关系，证明这个语言是可判定的与证明这个计算问题是可判定的是同一回事。
下面的定理将证明$L_{DFA}$是可判定的，因而也就证明了问题“一个给定的有穷自动机是否接受一个给定的串”是可判定的。
因此我们有定理：$L_{DFA}$是一个可判定语言。
证明思路：只要设计一个判定$L_{DFA}$的图灵机$M$即可。
$M$对于输入$<B,w>$，其中$B$是DFA,$w$是串：
1.检查输入$<B,w>$，它输入串$w$和DFA $B$。
2.在输入$w$上模拟$B$。
3.如果模拟以接收状态结束，则接受。如果以非接收状态结束，则拒绝。
证明：首先检查输入$<B,w>$，它输入串$w$和DFA $B$。$B$的一个合理的表示方式是简单地列出它的五个元素$Q,Σ, δ, q_0, F$。当$M$收到输入时，首先检查它是否正确地表示了DFA $B$和串$w$。如果不是，则拒绝。
然后$M$直接执行模拟。用在带子上写下信息的方法，它可以记录$B$在输入$w$上运行时的当前状态和当前位置。运行开始时，$B$的当前状态是$q_0$，读写头的当前位置是$w$的最左端符号。状态和位置的更新是由转移函数$δ$决定的。当$M$处理完$w$的最后一个符号时，如果$B$处于接受状态，则$M$接受这个输入，如果不是，则$M$拒绝。

类似地我们可以设$L_{NFA}=\{<B,w>|B是NFA并且接受输入串w\}$
定理：$L_{NFA}$是一个可判定语言。
证明：我们可以先上一个问题一样，设计一个新的图灵机$N$模拟NFA。但我们可以换一个思路，我们用$M$作为$N$的子程序。因此$M$被设计成只接受DFA作为输入，故$N$先将作为输入所收到的$NFA$转换成$DFA$，然后再将它传给$M$。
$N$对于输入$<B,w>$，其中$B$是NFA,$w$是串：
1.检查输入$<B,w>$，它输入串$w$和NFA $B$。
2.将NFA $B$转换成一个等价的DFA $C$。
3.再输入$<C,w>$上想前面那样运行图灵机$M$。
4.如果$M$接受，则接受，否则拒绝。

同理我们还可以通过DFA、NFA和正则表达式的等价性从而得到$L_{REX}=\{<R,w>|R是正则表达式，w是串，R派生w\}$

### 2.2.2 与上下文无关语言相关的可判定性问题
设$L_{CFG}=\{<G,w>|G是CFG,w是串,G派生w\}$
定理：$L_{CFG}$是一个可判定语言。
证明思路：对于$CFG$ G和串$w$要检查$G$是否产生$w$。一个思路是：让$G$遍历所有派生，以确定哪一个是$w$的派生。但这个思路行不通，因为这样可能要检查无限多个派生。如果$G$不产生$w$，这个算法将不终止。这个思路给出的图灵机只是$L_{CFG}$的一个识别器，而非判定器。
为将这个图灵机变成一个判定器，需要保证算法只检查有限多个派生。如果$G$是一个乔姆斯基范式，则$w$的任意派生都是$2n-1$步（先转换成变元在转换成终结符，但是生成变元是1个变为2个，所以是$2n-1$而不是$2n$），其中$n$是$w$的长度。此时，为确定$G$是否产生$w$，只需检查步长在$2n-1$内的派生即可，这样的派生只有有限多个。通过前面的知识，我们可以将$G$转换成乔姆斯基范式。
证明：识别$L_{CFG}$的图灵机$S$如下：
$S$对于输入$<G,w>$，其中，$G$是一个$CFG$，$w$是一个串：
1.将$G$转换成一个与之等价的乔姆斯基文法。
2.列出所有$2n-1$步的派生，其中$n$是$w$的长度，除非$n=0$，此时列出一步以内的派生。
3.如果这些派生中有一个产生$w$，则接受；如果没有，则拒绝。
这里的$S$的算法效率非常低，但是它很容易描述，后面的CYK算法会有效地识别一般的上下文无关语言。

现在我们引入另一种问题：emptiness（空性质检测），在下面的证明中，要检查一个自动机是否根本不接受任何串。

我们现在检查一个$CFG$是否不派生任何串是可判定的。设$E_{CFG}=\{<G>|G是一个CFG，且L(G)=∅\}$
定理：$E_{CFG}$是一个可判定语言。
证明思路：为检查一个文法的语言是否为空，需要检查起始变元能否产生一个终结符串。算法解决的是一个更一般的问题，它不仅检查起始变元，而且检查每一个变元，以确定这个变元能否产生一个终结符串。在确定某个变元能够产生一个终结符串后，算法就将这个变元作上标记，以记录这个信息。
算法先在文法中的所有终结符上作标记，然后扫描所有的文法规则。如果发现某个规则允许用符号串来取代一个变元，且符号串中的所有符号都已被作过标记，则算法知道，这个变元也能被作上标记。这样继续下去，直到找不到可以作标记的变元位置。下面的图灵机$R$实现这个算法。
证明：$R$对于输入$<G>$，其中$G$是一个$CFG$：
1.将$G$中所有的终结符全部作上标记。
2.重复下列步骤，直到找不到可以作标记的变元。
3.如果$G$有规则$A→U_1U_2...U_K$,且$U_1，U_2，...，U_K$中的每个符号都已被作过标记，则将变元$A$作标记。
4.如果起始变元没有被标记，则接受。否则拒绝。

## 2.3 Undecidable languages（不可判定语言）
人们相信所有问题最终都能被计算机解决，但是本质上计算机的能力是有限的。
现在介绍第一个不可解性定理。下面的语言是不可判定的：检查一个图灵机是否接受一个给定的串问题。类似于$L_{DFA}$和$L_{CFG}$，记之为$L_{TM}$，但$L_{DFA}$和$L_{CFG}$是可判定的，而$L_{TM}$不是。
令$L_{TM}=\{<M,w>|M是一个图灵机，且接受w\}$
定理：$L_{TM}$$L_{TM}$是不可判定的。
先证明$L_{TM}$是图灵可识别的。这样，本定理表明识别器确实比判定器更强大。要求图灵机(TM)在所有输入上都停机限制了它能够识别的语言种类。下面的图灵机$U$识别$L_{TM}$。
$U$对于输入$<M,w>$，其中$M$是一个图灵机，$w$是一个串：
1.在输入$w$上模拟$M$。
2.如果$M$进入接收状态，则接受。如果$M$进入拒绝状态，则拒绝。
注意，如果$M$在$w$上循环，则机器$U$在输入$<M,w>$上循环，这就是$U$不判定$L_{TM}$的原因。假如$M$知道自己在$w$上不停机，这种情况下它会拒绝。然而，算法本身无法做这样的决定。
这里的图灵机$U$是通用图灵机的一个例子，这种图灵机可以模拟任何其他图灵机。

### 2.3.1 Diagonalization method（对角化方法）
$L_{TM}$不可判定性的证明使用了diagonalization method（对角化方法），此方法由数学家Georg Cantor（康托）在1873年提出。这个方法可以解决无限集合之间的规模大小问题。例如，对所有偶数的集合和$\{0,1\}$上所有串的集合，这两个集合都是无限的，因而比任何有限集合都大，但它们中是否由一个比另一个更大呢？怎么比较它们的相对规模呢？
康托发现：对于两个有限集合，如果其中一个集合的元素能与另一集合的元素配对，则它们由相同的规模。这个方法没有凭借计数就比较了规模，因而可以将此类思想推广到无限集合上。这是它更准确的含义。
定义：设$A$和$B$是两个集合，$f$是从$A$到$B$的函数。如果$f$从不讲两个不同的元素映射到同一个对象，即只要$a≠b$就有$f(a)≠f(b)$，则称$f$是（one-to-one）一对一映射的。如果$f$能击中$B$的每个元素，即：对$B$的每个元素$b$，都存在$a∈A$，使得$f(a)=b$，则称$f$是surjective/onto（满映射）。如果存在函数$f:A→B$,$f$是一对一映射又是满映射，则称集合$A$和$B$有相同规模。而既是一对一映射又是满映射的函数称为correspondence（对应）。在对应中，$A$的每个元素映射到$B$的唯一一个元素，且$B$的每个元素都有$A$的唯一一个元素映射到它。对应就是将$A$的元素与$B$的元素进行配对的方法。
一对一映射又称为injective（单射），对应又称为bijective（双射）。

下面我们看一个例子：设$N$是自然数集合$\{1,2,3,...\}$,$Z$是偶自然数的集合$\{2,4,6,...\}$，用康托的关于集合规模的定义可以看到：$N$和$Z$有相同的规模。从$N$映射到$Z$的对应是$f（n）=2n$。如图所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/307757d9424d44ccbaa2f504f9f83945.jpeg#pic_center)
这个例子让人有些意外，因为直观上$Z$似乎比$N$小，因为$Z$是$N$的一个真子集。但由于能够将$N$的元素与$Z$进行配对。故可以下结论说这两个集合有相同的规模。

定义：如果一个集合$A$是有限的或者与$N$有相同的规模，则称$A$是countable（可数的）。

现在给出一个更令人意外的例子。设正有理数集合 $Q = \{m/n:m,n ∈ N \}$,证明这个集合是可数的。
这个集合看上去比$N$大很多，然后我们可以根据定义得出这两个集合的规模是相等的。如果给出$Q$到$N$的一个对应，这就证明了$Q$是可数的，从而证明了被结论。给出一个$Q$到$N$的对应的简单方法是：先列出$Q$的所有元素，然后将此序列中的第一个元素与$N$中的1配对，将第二个元素与$N$中的2配对，以此类推，但是需要注意$Q$中的每个元素在此序列中只出现一次。
为得到这样的序列，构造下面包含所有正有理数的矩阵，如下图所示。第$i$行包含所有分子为$i$的数，第$j$列包含所有分母为$j$的数。故$i/j$出现在第$i$行和第$j$列的交叉处。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7769a7e11b0c49f78c753876a418fde2.png)
但是将这个矩阵转换为序列时，一个行不通的思路是一行一行列出这些元素，因为第一行是无限的，所以永远不会到达第二行。所以我们从角落开始，排列在对角线上的所有元素，如下图所示，第一条对角线只包含一个元素$1/1$，第二条对角线包含两个元素$1/2$和$2/1$，所以此序列的前三个元素是$1/1$，$1/2$和$2/1$。第三条对角线上有麻烦，它包含$3/1$，$2/2$，$1/3$。如果简单地将它们加到序列中，就重复了$1/1=2/2$。为避免重复，忽略引起重复地元素。所以仅仅加入两个新元素$3/1$和$1/3$。以这样地方式继续下去，就得到$Q$的所有元素的一个序列。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b9048c90bf0c4842b37576dd3daff766.png)
看过$N$和$Q$的对应之后，可能会有这样的想法——任意两个无限集合都有相同的规模。毕竟只要给出一个对应即可，这个例子也说明了确实存在某些不可思议的队友。但是，还是有一些集合因为太大了，故没有与$N$的对应。这样的集合称为uncountable（不可数的）。
定义：如果一个无限集合与自然数集（N）之间不存在双射关系，那么这个无限集合就是不可数的。
实数集$R$便是不可数的，下面用对角线方法证明实数集$R$是不可数的。
定理：$R$是不可数的。
证明：为证明$R$是不可数的，必须证明在$N$与$R$之间不存在对应。下面用反证法证明：假设在$N$与$R$之间存在对应$f$，现在的任务是证明它没有应有的性质。因为它是一个对应，所以必能将$N$的所有元素与$R$的所有元素进行配对。如果能找到$R$中的一个$x$和$N$中的任何元素都不能配对，则找到了矛盾。
为此，实际构造出这样的一个$x$。方法为：在选择它的每一位数字时，都使得$x$不同于某个实数，且此实数已与$N$中一个元素配对。这样就能保证$x$不同于任何已配对的实数。
用一个例子来说明这个思路。假设对应$f$存在，且设$f(1)=3.14159...$，$f(2)=0.55555...$，$f(3)=...$，等等。则$f$将自然数$1$与$3.14159...$配对，将$2$与$0.55555...$配对。以此类推，如图所示，给出了此假定存在的$f$的一些值，$f$联系了$N$和$R$。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bf77c3ee16b549b2afba8a5432ebe778.png)
只要给出$x$的十进制表示，则$x$就可以构造出来。所构造的$x$是在0与1之间的一个数，所以重要的是小数点后面的数字。要保证对每个$n$都有$x≠f(n)$。为保证$x≠f(1)$，只要保证$x$的第一位小数不同于$f(1)=3.14159...$的第一位小数，即不是数字1，随意地令其为4.为保证$x≠f(2)$，只要保证$x$地第二位小鼠不同于$f(2)=0.55555...$的第二位小数，既不是数字5，我们可以令其为6。为保证$x≠f(3)$，只要保证$x$的第三位小数不同于$f(3)=40.00000...$的第一位小数，即不是数字0，随意取一个4.沿着下图的$f$的对角线，我们可以得到$x$的所有数字。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0b1c04296fea4422a694caffa5b0e316.png)
不难知道，对任意的$n$，$x$都不是$f(n)$，因为$x$与$f(n)$在第$n$个小数位上不同。（有一个小问题。有些数，比如$0.1999...$和$0.2000...$，虽然它们的十进制表示不同，但它们却相同。只要在构造$x$时不选数字0和9，就可避免这个问题。）
最后我们一定可以构造出这个$x$不存在在$R$中，这就出现了一个矛盾，因此我们可以得到实数集$R$时不可数的。

上述定理对计算理论有着重要的应用，它表明有些语言是不可判定的，甚至不是图灵可识别的，原因是：有不可数个语言，却只有可数个图灵机。由于一个图灵机只能识别一个语言，而语言比图灵机更多，故有些语言不能用任何的图灵机识别。这样的语言就不是图灵可识别的。

现在我们有了足够的知识证明下列语言的不可判定性：
$A_{TM}=\{<M,w>|M是一个图灵机，且M接受w\}$
证明：假设$A_{TM}$是可判定的，下面将由之导出矛盾。设$H$是$A_{TM}$的判定器。令$M$是一个图灵机，$w$是一个串。在输入$<M,w>$上，如果$M$接受$w$，则$H$就停机且接受$w$。如果$M$不接受$w$，则$H$也会停机，但拒绝$w$。换句话说，$H$是一个图灵机，使得：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fab9e3b0c4ae4b37a5c2c71afb0a1761.png)
现在来构造一个新的图灵机$D$，它以$H$作为子程序。当$M$被输入它自己的描述$<M>$时。图灵机就调用$H$，以了解$M$将做什么。一旦得到这个消息，$D$就反着做，即：如果$M$接受，它就拒绝。如果$M$不接受，它就接受。关于$D$的描述如下：
$D$对于输入$<M>$，其中$M$是一个图灵机：
1.在输入$<M,<M>>$上运行$H$。
2.输出与$H$输出的相反结论，即如果$H$接受，就拒绝。如果$H$拒绝，就接受。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/047b6c2c4c9b4d8b92c257a6dbc7347a.png)
当我们以$D$的描述$<D>$作为输入来运行$D$自身时，结果会怎样呢？我们得到:
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/577563b69e0341548d9b93ddc900e10e.png)
无论$D$做什么，它都被迫相反地做，这显然是一个矛盾。所以，图灵机$D$和图灵机$H$都不存在。
在上述证明步骤中，我们先假设图灵机$H$判定$A_{TM}$，然后用$H$来构造一个图灵机$D$，它接受输入$<M>$当且仅当$M$不接受输入$<M>$，最后在$D$自身上运行$D$。因此这些机器发生下列动作：
1.$H$接受$<M,w>$当且仅当$M$接受$w$。
2.$D$拒绝$<M>$，当且仅当$M$接受$<M>$。
2.$D$拒绝$<D>$，当且仅当$D$接受$<D>$。
这里的最后一行是矛盾的。（这也是CPT201最后提到的停机问题中的一个实例）
这个证明中，有什么地方用到了对角化呢？在图灵机$H$和图灵机$D$的行为表中，所有图灵机$M_1$，$M_2$，...沿列方向排列，将它们的描述$<M_1>$，$<M_2>$，...沿行方向排列。表值说明了所在行中的机器是否接受所在列中的输入，如接受，则表值为accept。如拒绝或在此输入上循环，则表值为空白。如图所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1c6a6a1b18e341bfb1762b6d52ec7922.png)
而$H$的运行结果，如下图所示，如果$M_3$不接受输入$<M_2>$则在第$M_3$行和第$<M_2>$列交叉处的表值是reject，因为$H$拒绝输入$<M_3,<M_2>>$。
下图是加入$D$后的情况。根据假设，$H$是一个图灵机，所以$D$也是一个图灵机，因此必定在所有图灵机的序列$M_1$，$M_2$，...中出现。注意，$D$按对角线表值得相反值计算。在问号处产生矛盾，那里的表值必须与它自己相反。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cca7360a319c4cc1b82eaf3e689b4f34.png)
### 2.3.2 Non Turning-recognizable languages（图灵不可识别语言）
$L_{TM}$是不可判定的语言，但它是图灵可识别的。
下面介绍图灵不可识别的语言，下面的定理表面：如果一个语言和它的补都是图灵可识别的，则此语言也是可判定的。这样，对任何不可判定语言，它或它的补至少有一个不是图灵可识别的。回想一下，一个语言的补是由不在此语言中的所有串构成的语言。如果一个语言是一个图灵可识别语言的补集，则称它是co-Turning-recognizable（补图灵可识别的）。

定理：一个语言是可判定的，当且仅当它既是图灵可识别的，也是补图灵可识别的。
换句话说，一个语言是可判定的，当且仅当它和它的补都是图灵可识别的。
证明：要证明两个方向。首先，如果$A$是可判定的，很容易看出$A$和它的补$\overline{A}$都是图灵可识别的，因为任何可判定语言都是图灵可识别的，且任何可判定语言的补也是可判定的。
下面证明另一个方向。如果$A$和$\overline{A}$都是图灵可识别的，令$M_1$是$A$的识别器，$M_2$是$\overline{A}$的识别器。下列图灵机$M$是$A$的判定器。
$M$对于输入$w$：
1.在输入$w$上并行运行$M_1$和$M_2$。
2.如果$M_1$接受，就接受。如果$M_2$接受，就拒绝。
并行运行的意思是：$M$有两个带，一个模拟$M_1$，另一个模拟$M_2$。此时$M$交替模拟两个机器的一步，一直持续到其中之一接受。
现在证明$M$确实判定$A$。任一串$w$要么在$A$中，要么在$\overline{A}$中。所以$M_1$和$M_2$必定有一个接受$w$。因为只要$M_1$或$M_2$接受，$M$就停机，所以$M$总会停机，因而它是个判定器。还有，$M$接受所有在$A$中的串，拒绝所有不在$A$中的串，故$M$是$A$的判定器，因而$A$是可判定的。

推论：$\overline{L_{TM}}$是图灵不可识别的。
证明：因为$L_{TM}$是图灵可识别的，如果$\overline{L_{TM}}$是图灵可识别的，则$L_{TM}$是可判定的。但$L_{TM}$是不可判定的，所以$\overline{L_{TM}}$是图灵不可识别的。

# 3. Reducibility and Rice’s Theorem(可归约性和赖斯定理）
我们前文已经说过了图灵机和算法的关系。在算法中我们有reduction（归约），同样地在图灵机中我们也有归约。我们将使用reducibility（归约性）来证明一些问题是计算上不可解的。

## 3.1 Background
Undecidable Problems（不可判定问题）：
一个问题的associated language（相关语言）无法被图灵机在所有输入上停机的情况下识别。这里的相关语言是前文中类似于L_{TM}={<B,w>|B是TM并且接受输入串w}这样的语言。后半句的意思是不存在一个判定器。

Unrecognizable problem.（不可识别问题）：
一个问题的相关语言无法被图灵机识别。

比如关于图灵机的语言是不可判定的，但它是可识别的。
$L_{TM}= \{<M, w> : M是接受字符串w的图灵机\}$。
对于不可判定的问题，通常认为它们是unsolvable（无法解决的），即使图灵机运行了很长时间也无法给出答案。相比之下，对于可判定的语言，存在一个等待时间的上限，但对于不可判定的语言，等待时间没有限制。

## 3.2 Reducibility（可规约性）
Reduction（归约）旨在将一个问题转换为另一个问题，且使得可以用第二个问题的解来解第一个问题。例如在一个城市认路可以归约为得到地图的问题，因为我们有地图就可以认路了。
Reducibility（可归约性）总是涉及两个问题，称之为$A$和$B$。如果$A$可reduces to（归约到）$B$，就可以用B的解来解$A$。在上述的例子中，$A$是城市认路问题，$B$是得到地图问题。我们在知道$B$的解时就可以去解$A$。
再比如我需要从北京去巴黎旅游，这个问题可以归于到买飞机票的问题，这个问题又可以进一步归约到挣钱买飞机票的问题，这个问题又可以进一步归约到找工作赚钱的问题。
再比如数学上我想获得一个矩形的面积，这个问题可以归约到获得长和宽的问题。
从上述的例子中我们可以得到。当$A$可归于到$B$时，解$A$不可能比解$B$更难，因为$B$的一个解给出了$A$的一个解。所以根据可计算性理论，如果A可归约到$B$，且$B$是可判定的，则$A$也是可判定的。等价地，如果$A$可归约到$B$，且$A$是不可判定的，则$B$也是不可判定的。

因此我们可以通过归约的方法去证明一个语言$L$是不可判定的，步骤如下：
1.找到一个已知是不可判定的问题$A$。
2.假设$L$是可判定的。
3.假设存在一个图灵机$R$能够判定$L$。
4.使用$R$作为子程序来构造另一个图灵机$S$来判定$A$。
5.但是$A$是不可判定的。
6.结论：$L$是不可判定的。

例子如下：我们前面知道了$A_{TM}$是不可判定的，即确定一个图灵机是否接受一个给定的输入问题是不可判定的。那么对于问题：$HALT_{TM}$，即确定一个图灵机对给定的输入是否停机问题。这个问题被称为halting problem（停机问题）。若将$A_{TM}$归约到$HALT_{TM}$就可以利用$A_{TM}$的不可判定性来证明停机问题的不可判定性。设$HALT_{TM}=\{<M,w>|M是一个图灵机，且对输入w停机\}$。
证明思路：按照前面的思路我们已经完成了第一步，我们找到了不可判定的问题$A_{TM}$。
第二步我们假设$HALT_{TM}$是可判定的。
下一步我们用能够判定$HALT_{TM}$的图灵机$R$去构造一个判定$A_{TM}$的图灵机$S$。当$R$指出$M$对$w$不停机，$S$就直接拒绝，因为$<M,w>$不在$A_{TM}$中。如果$R$指出$M$对$w$停机，则$S$模拟$M$。如果$M$接受$w$，则$S$就接受。如果$M$拒绝$w$，则$S$就拒绝。
因此如果$R$存在，那么就能判定$A_{TM}$，但是$A_{TM}$是不可判定的。因此矛盾，所以$R$不存在，因此$HALT_{TM}$是不可判定的。
证明：假设图灵机$R$判定$HALT_{TM}$，由之可以构造图灵机$S$来判定$A_{TM}$，其构造如下：
$S=$“在输入$<M,w>$上，此处$<M,w>$是图灵机$M$和串$w$的编码：
1.在输入<M,w>上运行图灵机$R$。
2.如果$R$拒绝，则拒绝。
3.如果$R$接受，则在$w$上模拟$M$，直到他停机。
4.如果$M$已经接受，则接受；如果$M$已经拒绝，则拒绝。”
显然，如果$R$判定$HALT_{TM}$，则$S$判定$A_{TM}$。因为$A_{TM}$是不可判定的，故$HALT_{TM}$也必定是不可判定的。

用归约的方法证明不可判定性对大多数不可判定性证明都适用，只是除了$A_{TM}$本身的不可判定性证明之外，它是由对角化方法直接证明的。

为进一步使用可规约性方法来证明不可判定性，现在介绍另外一些定理及相应的证明。设
$E_{TM}=\{<M>|M是一个图灵机，且L(M)= ∅\}$
现在证明$E_{TM}$是不可判定的。这个问题我们不能像前面证明CFG的时候一样列出所有的生成。
证明思路：假设$E_{TM}$是可判定的，以此来证明$A_{TM}$是可判定的，从而得出矛盾。所以我们现在的问题关键是考虑怎么用判定$E_{TM}$的图灵机$R$去构造判定$A_{TM}$的图灵机$S$。
在这个构造中我们如果在输入$<M>$上运行$R$且看它是否接受。如果是，则知道$L<M>$是空集，因此也就知道$M$不接受$w$。如果$R$拒绝$<M>$，则能知道$L<M>$不为空，但是$M$是否接受这个特定的串$w$是不知道的。故需要新的方法。
现在不在$<M>$上运行$R$，取而代之的是在$<M>$的一个修改型上运行$R$。先修改$<M>$，使得除了$w$之外，$M$对所有串都拒绝，但在输入$w$上，它如常运行。现在，此修改型所能识别的唯一的串就是$w$，故它的语言不空当且仅当它接受$w$。然后再用$R$来测定这个修改型是否识别空语言。为此，向$R$提供那个修改型机器的描述，如果它接受，则此修改型机器不接受任何串，因而$M$也就不接受$w$。
证明：$M_1=$“在输入$x$上：
1.如果$x≠w$，则拒绝。
2.如果$x=w$，则在输入$w$上运行$M$，当$M$接受时，就接受。”
这个时修改型$M$，通过比较$x$和$w$的每一个字符从而确定它们是否相同。
再假设图灵机$R$判定$E_{TM}$ 。如下构造判定$A_{TM}$的图灵机$S$：
$S=$“输入$<M,w>$上，此处$<M,w>$是图灵机$M$和串$w$的编码：
1.用$M$和$w$的描述来构造上述图灵机$M_1$。
2.在输入$<M_1>$上运行$R$。
3.如果$R$接受，则拒绝；如果$R$拒绝，则接受。”
如果$R$是$E_{TM}$的判定器，则$S$就是$A_{TM}$的判定器。而$A_{TM}$的判定器是不存在的，故我们知道$E_{TM}$必定是不可判定的。

## 3.3 Mapping reducibility/Many-one reducibility（映射可归约性/多一可归约性）
我们现在将可归约性这个概念形式化。将一个问题归约为另一个问题的概念可以用多种方式来形式定义，选择使用哪种方式要根据具体应用情况。我们的选择是一种简单方式的可归约性，叫作mapping reducibility（映射可归约性）。
我们现在想象存在一个可计算函数，它将问题$A$的实例转换成问题$B$的实例。如果有了这样一个转换函数（称为归约），就能用$B$的解决方案来解$A$。因为我们现在可以用这个转换函数(归约)将$A$的任何一个实例转换为$B$的一个实例，然后应用$B$的解决方案去解决。

### 3.3.1 Computable function（可计算函数）
图灵机计算函数的方式是：将函数的输入放在带子上，开始运行，并以停机后的带子作为函数的输出。
定义：函数$f;Σ^∗ →Σ^∗$是一个computable function（可计算函数），如果有某个图灵机$M$，使得在每个输入$w$上$M$停机，且此时只有$f(w)$出现在带子上。
整数上的所有通常的算术运算都是可计算函数。例如我们现在有一个图灵机，它会接受所有$<m,m>$形式的输入，它会返回$m$与$n$的和$m+n$。
可计算函数也可以是机器的描述之间的变换。例如，如果$w=<M>$是图灵机$M$的编码，则可以由一个可计算函数$f$，以$w$为输入，且返回一个图灵机的描述$<M'>$。$M'$是一个与$M$识别相同语言的机器，但$M'$从不试图将它的读写头移出它的带子的左端点。函数$f$通过在$M$的描述中加入一些状态来完成这个任务。如果$w$不是图灵机的合法编码，$f$就返回$ε$。

### 3.3.2 映射可归约性的形式化定义
现在定义映射可归约性。
语言$A$是定义在字母表$Σ_1$上的，即$A ⊆ Σ_1^*$，语言$B$是定义在字母表$Σ_2$上的，即$B ⊆ Σ_2^*$。如果存在可计算函数$f:Σ_1^*→Σ_2^*$使得对每个$w$，$w∈A ⇔f(w) ∈B$，记作$A≤_mB$，称函数$f$为从$A$到$B$的归约。
如图所示。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cf74a2786b6a4430a174176e131e8b47.png)
$A$到$B$的映射归约提供了将$A$的成员测试问题转换为$B$的成员测试问题的方法。为了检查是否有$w∈A$，可使用这个归约$f$将$w$映射到$f(w)$，然后检查是否$f(w)∈B$。

因此现在如果一个问题映射可归约到第二个问题，且第二个问题先前已被解决，那就能得到原来问题的解。即定理：如果$A≤_mB$且$B$是可判定的，则$A$也是可判定的。
证明：设$M_B$是$B$的判定器，$f$是从$A$到$B$的归约。$A$的判定器$M_A$的描述如下：$M_A=$“对于输入$w$:
1.计算$f(w)$。
2.在$f(w)$上运行$M_B$，输出$M_B$的输出。”
显然，如果$w∈A$,则$f(w)∈B$，因为$f$是从$A$到$B$的归约。因此，只要$w∈A$,则$f(w)∈B$，则$M_B$和$M_A$都会接受。同理，$w∉A$,则$f(w)∉B$，则$M_B$和$M_A$都会拒绝。因此我们得到了$A$的判定器$M_A$。

所以我们可以得到推论：如果$A≤_mB$且$A$是不可判定的，则$B$也是可判定的。
我们还可以得到类似的定理：如果$A≤_mB$且$B$是图灵可识别的，则$A$也是图灵可识别的。
推论：如果$A≤_mB$且$A$是图灵不可识别的，则$B$也是图灵不可识别的。

下面我们用映射可归约性证明$HALT_{TM}$的不可判定性。因此我们需要提供一个可计算函数$f$，使用形如$<M,w>$的输入，返回$<M',w'>$的输出，使得$<M,w>∈A_{TM}$当且仅当$<M',w'>∈HALT_{TM}$。
下面的机器$F$计算了归约$f$：
$F=$“对于输入$<M,w>$：
1.构造下列图灵机$M'$。
$M'=$‘对于输入$x$：
a.在$x$上运行$M$。
b.如果$M$接受，则接受。
c.如果$M$拒绝，则进入循环。'
2.输出$<M',w>$。”
这里如果有形式不正确的输入，那么此输入不在$A_{TM}$中，那么这个图灵机输出的串也不在$HALT_{TM}$中。这里应当指出如何处理所有不在$HALT_{TM}$中的串。通常而言，当我们描述一个图灵机进行$A$到$B$的归约时，都假定形式不正确的输入串已经被映射到$B$之外了。

## 3.4 Rice’s Theorem（赖斯定理）
还有一些其他的不可判定问题，例如：
$INFINITE_{TM} = \{<M> | M 是一个图灵机并且|L(M)| = ∞ \}$
$LT_{TM} = \{<M> | M 是一个图灵机并且|L(M)| = |L(T)|\}$
$FINITE_{TM} = \{<M> | M 是一个图灵机并且存在一个n∈N，|L(M)| =n\}$
$ALL_{TM}=\{<M>|M是一个图灵机并且L(M) = Σ^∗\}$
包括前文提到的$E_{TM}=\{<M>|M是一个图灵机，且L(M)= ∅\}$
我们其实可以使用Rice’s Theorem（赖斯定理）快速证明它们是不可判定的。

Rice’s Theorem（赖斯定理）指出，对于任何图灵机的语言的非平凡属性$P$，证明确定某一图灵机的语言是否具有属性$P$这一问题是不可判定的。

### 3.4.1 赖斯定理的形式化定义
定义$T$是所有图灵机描述的集合，即$T=\{<M>M是一个图灵机\}$。
那么$P$就是$T$的一个子集，并满足下列三个条件：
1.$P ≠∅$，即存在一个图灵机$M$可以使$<M>∈P$。
2.$P$是$T$的真子集，即存在一个图灵机$N$满足$<N>∉P$。
3.对于任意的两个图灵机$M_1$和$M_2$如果满足$L(M_1)=L(M_2)$，要么$<M_1>$和$<M_2>$都在$P$中，要么$<M_1>$和$<M_2>$都不在$P$中。（无论何时$L(M_1)=L(M_2)$，当且仅当$<M_2>∈P$时，有$<M_1>∈P$，此时$M_1$和$M_2$是任意图灵机。）
那么语言$P$是不可判定语言。

我们现在使用归约证明赖斯定理。我们会将$L_{TM}$归约到所有非平凡属性问题。对于给定问题$P$，有一个判定器$R_P$和一个图灵机$T$满足$<T>∈ P$。对于给定的图灵机$M$和输入$w$，理想情况下，我们构造出一个图灵机$M_w$，使得$M$接受$w$当且仅当$<M_w>∈ P$。
$M_w(T)=$“对于输入$x$:
1.在$w$上运行$M$。如果$M$停机并拒绝，则拒绝。如果$M$接受，跳转到步骤2。
2.在$x$上运行$T$。如果$T$接受，则接受。
因此如果$M$接受$w$，则$L(M_w(T))=L(T)$。因为$L(T)∈P$，所以$<M_w(T)>∈P$。
如果$M$拒绝$w$或在$w$上循环，则$L(M_w(T))=∅$，所以$<M_w(T)>∉P$当且仅当具有空语言的图灵机不满足某个属性$P$。
如果属性$P$包括空语言，上述的证明便不适用。
现在我们假设$M_∅$是一个接受空语言的图灵机。如果$<M_∅>∈P$，我们便使用其的补集$\overline{P}$。
显然，当$P$是一个决定器的时候$\overline{P}$也是一个决定器。
此外，始终存在$< \overline{T} > ∈ \overline{P}$当$P$是真子集的时候。
如果$M$接受$w$，则$L(M_w(\overline{T}))=L(\overline{T})$。因为$L(\overline{T})∈\overline{P}$，所以$<M_w(\overline{T})>∈\overline{P}$。
如果$M$拒绝$w$不停机，则$L(M_w(\overline{T}))=∅$，所以$<M_w(\overline{T})>∉\overline{P}$。
因此当$<M_∅>∈P$，$M$接受$w$当且仅当$<M_w(\overline{T})>∈\overline{P}$。
由于$L_{TM}$是不可判定的，所以所有非平凡属性问题也是不可判定的。
我们便证明了赖斯定理。

我们现在尝试用赖斯定理去解决前面说的那些问题。
$E_{TM}=\{<M>|M是一个图灵机，且L(M)= ∅\}$
1.一个拒绝所有输入的图灵机在$P$中，因此$P ≠∅$。
2.一个接受所有输入的图灵机一定不在$P$中，因此$P$是$T$的真子集。
3.如果$L(M_1)=L(M_2)$，它们要么都是空集，要么都是非空，因此它们要么都在$P$中要么都不在$P$中。
因此根据赖斯定理，$E_{TM}$是不可判定的。

$INFINITE_{TM} = \{<M> | M 是一个图灵机并且|L(M)| = ∞ \}$
1.一个接受所有输入的图灵机在$P$中，因此$P ≠∅$。
2.一个拒绝所有输入的图灵机一定不在$P$中，因此$P$是$T$的真子集。
3.如果$L(M_1)=L(M_2)$，那么如果$|L(M_1)|=|L(M_2)|$所以它们要么都是无穷的，要么都是有穷的，因此它们要么都在$P$中要么都不在$P$中。
因此根据赖斯定理，$INFINITE_{TM}$是不可判定的。
注意：可能存在$M_1,M_2∈INFINITE_{TM}$但是$L(M_1)≠L(M_2)$。

由于赖斯定理针对的是语言的属性而不是图灵机本身的属性，因此它无法用于处理下面的问题。
$FIVE_{TM}=\{<M> | M是一个含有五个状态的图灵机\}$，因为可以通过模拟具有3个状态的通用图灵机（UTM）来识别与给定的5个状态图灵机相同的语言。
